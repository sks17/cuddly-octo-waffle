<!DOCTYPE html>
<html>
<head>
    <title>Background Generator Comparison Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #1a1a1a;
            color: white;
        }
        .test-section {
            margin: 30px 0;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 8px;
        }
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .output-panel {
            border: 2px solid #444;
            border-radius: 8px;
            padding: 15px;
            background: #333;
        }
        .output-panel h3 {
            margin: 0 0 15px 0;
            color: #4CAF50;
        }
        canvas, img {
            border: 1px solid #666;
            background: black;
            max-width: 100%;
        }
        .controls {
            margin: 20px 0;
        }
        button {
            background: #4a4a4a;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background: #5a5a5a;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .status.success { background: #2d5a2d; color: #90EE90; }
        .status.error { background: #5a2d2d; color: #FFB6C1; }
        .status.info { background: #2d4a5a; color: #87CEEB; }
        .metrics {
            font-family: monospace;
            font-size: 12px;
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .test-params {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        .param-group {
            display: flex;
            flex-direction: column;
        }
        .param-group label {
            font-size: 12px;
            margin-bottom: 5px;
        }
        .param-group input, .param-group select {
            padding: 8px;
            border: 1px solid #666;
            border-radius: 4px;
            background: #1a1a1a;
            color: white;
        }
    </style>
</head>
<body>
    <h1>üé® Background Generator Comparison Test</h1>
    <p>Compare traditional server-side PNG generation vs. distributed client-side rendering</p>

    <div class="test-section">
        <h2>Test Parameters</h2>
        <div class="test-params">
            <div class="param-group">
                <label>Width</label>
                <input type="number" id="width" value="400" min="100" max="1200">
            </div>
            <div class="param-group">
                <label>Height</label>
                <input type="number" id="height" value="300" min="100" max="900">
            </div>
            <div class="param-group">
                <label>Cell Size</label>
                <input type="number" id="cellSize" value="20" min="5" max="50">
            </div>
            <div class="param-group">
                <label>Hue</label>
                <select id="hue">
                    <option value="purple">Purple</option>
                    <option value="blue">Blue</option>
                    <option value="teal">Teal</option>
                    <option value="green">Green</option>
                    <option value="red">Red</option>
                    <option value="orange">Orange</option>
                    <option value="yellow">Yellow</option>
                    <option value="gray">Gray</option>
                    <option value="pink">Pink</option>
                </select>
            </div>
            <div class="param-group">
                <label>Pattern</label>
                <select id="pattern">
                    <option value="mixed">Mixed</option>
                    <option value="uniform">Uniform</option>
                    <option value="gradient">Gradient</option>
                </select>
            </div>
        </div>

        <div class="controls">
            <button onclick="runComparisonTest()">üîÑ Run Comparison Test</button>
            <button onclick="generateTraditional()">üñºÔ∏è Traditional Only</button>
            <button onclick="generateDistributed()">‚öôÔ∏è Distributed Only</button>
            <button onclick="clearOutputs()">üßπ Clear</button>
        </div>

        <div id="status"></div>
    </div>

    <div class="comparison-grid">
        <div class="output-panel">
            <h3>Traditional Rendering (Server PNG)</h3>
            <img id="traditional-output" style="display:none;">
            <div id="traditional-metrics" class="metrics"></div>
        </div>
        
        <div class="output-panel">
            <h3>Distributed Rendering (Client Canvas)</h3>
            <canvas id="distributed-output"></canvas>
            <div id="distributed-metrics" class="metrics"></div>
        </div>
    </div>

    <div class="test-section">
        <h2>üìä Comparison Results</h2>
        <div id="comparison-results" class="metrics"></div>
    </div>

    <script>
        const API_BASE = 'http://127.0.0.1:5000/api';
        
        function setStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        function getTestParams() {
            return {
                canvas_width: parseInt(document.getElementById('width').value),
                canvas_height: parseInt(document.getElementById('height').value),
                cell_size: parseInt(document.getElementById('cellSize').value),
                hue: document.getElementById('hue').value,
                pattern: document.getElementById('pattern').value,
                low: 0,
                high: 1,
                normalizer: 0.5,
                use_determinant: true,
                use_max: true,
                max_matrix_size: 4,
                blur_sigma: 1.5,
                vignette_strength: 0.3,
                gap_cells: 1,
                feather_strength: 0.0
            };
        }

        async function generateTraditional() {
            setStatus('Generating traditional PNG...', 'info');
            const startTime = performance.now();
            
            try {
                const params = getTestParams();
                const response = await fetch(`${API_BASE}/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(params)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const blob = await response.blob();
                const url = URL.createObjectURL(blob);
                
                const img = document.getElementById('traditional-output');
                img.src = url;
                img.style.display = 'block';
                
                const endTime = performance.now();
                const metrics = {
                    method: 'Traditional (Server PNG)',
                    time: `${(endTime - startTime).toFixed(1)}ms`,
                    size: `${(blob.size / 1024).toFixed(1)}KB`,
                    dimensions: `${params.canvas_width}√ó${params.canvas_height}`,
                    hue: params.hue
                };
                
                document.getElementById('traditional-metrics').textContent = 
                    Object.entries(metrics).map(([k,v]) => `${k}: ${v}`).join('\n');
                
                setStatus('Traditional rendering complete!', 'success');
                return { success: true, metrics, blob };
                
            } catch (error) {
                setStatus(`Traditional rendering failed: ${error.message}`, 'error');
                return { success: false, error: error.message };
            }
        }

        async function generateDistributed() {
            setStatus('Generating distributed render spec...', 'info');
            const startTime = performance.now();
            
            try {
                const params = getTestParams();
                const response = await fetch(`${API_BASE}/render-spec`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(params)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const spec = await response.json();
                const renderStartTime = performance.now();
                
                // Client-side rendering
                await renderFromSpec(spec);
                
                const endTime = performance.now();
                const metrics = {
                    method: 'Distributed (Client Canvas)',
                    'spec time': `${(renderStartTime - startTime).toFixed(1)}ms`,
                    'render time': `${(endTime - renderStartTime).toFixed(1)}ms`,
                    'total time': `${(endTime - startTime).toFixed(1)}ms`,
                    blocks: spec.blocks.length,
                    dimensions: `${spec.canvas.width}√ó${spec.canvas.height}`,
                    'det range': `${spec.determinant_range.min} to ${spec.determinant_range.max}`,
                    hue: spec.visual.hue
                };
                
                document.getElementById('distributed-metrics').textContent = 
                    Object.entries(metrics).map(([k,v]) => `${k}: ${v}`).join('\n');
                
                setStatus('Distributed rendering complete!', 'success');
                return { success: true, metrics, spec };
                
            } catch (error) {
                setStatus(`Distributed rendering failed: ${error.message}`, 'error');
                return { success: false, error: error.message };
            }
        }

        async function runComparisonTest() {
            setStatus('Running comparison test...', 'info');
            clearOutputs();
            
            const startTime = performance.now();
            
            // Run both methods
            const [traditional, distributed] = await Promise.all([
                generateTraditional(),
                generateDistributed()
            ]);
            
            const totalTime = performance.now() - startTime;
            
            // Analyze results
            if (traditional.success && distributed.success) {
                const comparison = {
                    'Test Status': 'SUCCESS - Both methods completed',
                    'Total Test Time': `${totalTime.toFixed(1)}ms`,
                    'Traditional Time': traditional.metrics.time,
                    'Distributed Time': distributed.metrics['total time'],
                    'Block Count': distributed.spec.blocks.length,
                    'Determinant Range': `${distributed.spec.determinant_range.min} to ${distributed.spec.determinant_range.max}`,
                    'PNG Size': traditional.metrics.size,
                    'Canvas Dimensions': traditional.metrics.dimensions
                };
                
                // Visual similarity check (basic)
                setTimeout(() => {
                    try {
                        const similarity = performVisualComparison();
                        comparison['Visual Similarity'] = `${(similarity * 100).toFixed(1)}% (estimated)`;
                    } catch (e) {
                        comparison['Visual Similarity'] = 'Unable to measure automatically';
                    }
                    
                    document.getElementById('comparison-results').textContent = 
                        Object.entries(comparison).map(([k,v]) => `${k}: ${v}`).join('\n');
                }, 1000);
                
                setStatus('Comparison test completed successfully! ‚ú®', 'success');
            } else {
                const errors = [];
                if (!traditional.success) errors.push(`Traditional: ${traditional.error}`);
                if (!distributed.success) errors.push(`Distributed: ${distributed.error}`);
                
                document.getElementById('comparison-results').textContent = 
                    `COMPARISON FAILED:\n${errors.join('\n')}`;
                setStatus('Comparison test failed', 'error');
            }
        }

        function performVisualComparison() {
            // Basic visual similarity check by comparing image data
            // This is a simplified approach - in practice you'd need more sophisticated comparison
            try {
                const canvas = document.getElementById('distributed-output');
                const img = document.getElementById('traditional-output');
                
                if (!img.complete || !canvas.width) {
                    return 0.5; // Unknown similarity
                }
                
                // Create temporary canvas to compare
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const ctx = tempCanvas.getContext('2d');
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                
                const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const canvasCtx = canvas.getContext('2d');
                const canvasData = canvasCtx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Simple pixel difference check (sample points)
                let matches = 0;
                let total = 0;
                for (let i = 0; i < imgData.data.length; i += 16) { // Sample every 4th pixel
                    const diff = Math.abs(imgData.data[i] - canvasData.data[i]) +
                                Math.abs(imgData.data[i+1] - canvasData.data[i+1]) +
                                Math.abs(imgData.data[i+2] - canvasData.data[i+2]);
                    if (diff < 30) matches++; // Allow some tolerance for compression/rounding
                    total++;
                }
                
                return matches / total;
            } catch (e) {
                console.error('Visual comparison error:', e);
                return 0.5; // Unknown similarity
            }
        }

        async function renderFromSpec(spec) {
            const canvas = document.getElementById('distributed-output');
            canvas.width = spec.canvas.width;
            canvas.height = spec.canvas.height;
            
            const ctx = canvas.getContext('2d');
            const cellSize = spec.canvas.cell_size;
            
            // Clear canvas
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Color mapping function (matches backend color_from_integer logic)
            function colorFromInteger(value, low, high, normalizer, hue) {
                const hueColors = {
                    'gray': [128, 128, 128],
                    'red': [200, 100, 100],
                    'orange': [200, 150, 100],
                    'yellow': [200, 200, 100],
                    'green': [100, 200, 100],
                    'teal': [100, 200, 200],
                    'blue': [100, 100, 200],
                    'purple': [150, 100, 200],
                    'pink': [200, 100, 150]
                };
                const baseColor = hueColors[hue] || hueColors.gray;
                
                // Color transformation based on matrix element value
                const factor = value === low ? 0.3 : 1.2;  // 0s darker, 1s brighter
                
                const r = Math.min(255, Math.max(30, baseColor[0] * factor * normalizer + 40));
                const g = Math.min(255, Math.max(30, baseColor[1] * factor * normalizer + 40));
                const b = Math.min(255, Math.max(30, baseColor[2] * factor * normalizer + 40));
                
                return [r, g, b];
            }
            
            const { min: detMin, max: detMax } = spec.determinant_range;
            
            // Render each block by drawing individual matrix elements
            spec.blocks.forEach(block => {
                const matrix = block.matrix;
                const matrixSize = matrix.length;
                
                // Calculate brightness factor from determinant
                let brightnessFactor = 1.0;
                if (spec.visual.use_determinant && detMax > detMin) {
                    const detNorm = (block.determinant - detMin) / (detMax - detMin);
                    brightnessFactor = spec.visual.use_max ? 
                        0.5 + 0.5 * detNorm : 
                        0.5 + 0.5 * (1.0 - detNorm);
                }
                
                // Render each matrix element as individual cells
                for (let i = 0; i < matrixSize; i++) {
                    for (let j = 0; j < matrixSize; j++) {
                        // Get base color for this matrix element
                        const baseColor = colorFromInteger(
                            matrix[i][j], 
                            spec.visual.low, 
                            spec.visual.high,
                            spec.visual.normalizer, 
                            spec.visual.hue
                        );
                        
                        // Apply brightness factor from determinant
                        const r = Math.min(255, baseColor[0] * brightnessFactor);
                        const g = Math.min(255, baseColor[1] * brightnessFactor);
                        const b = Math.min(255, baseColor[2] * brightnessFactor);
                        
                        // Calculate cell position
                        const cellX = block.x + j * cellSize;
                        const cellY = block.y + i * cellSize;
                        
                        // Draw individual cell
                        ctx.fillStyle = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
                        ctx.fillRect(cellX, cellY, cellSize, cellSize);
                    }
                }
            });
            
            // Apply vignette if specified (simplified)
            if (spec.visual.vignette_strength > 0) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);
                
                const gradient = ctx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, maxDist
                );
                gradient.addColorStop(0, `rgba(0,0,0,0)`);
                gradient.addColorStop(1, `rgba(0,0,0,${spec.visual.vignette_strength})`);
                
                ctx.globalCompositeOperation = 'multiply';
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalCompositeOperation = 'source-over';
            }
        }

        function clearOutputs() {
            document.getElementById('traditional-output').style.display = 'none';
            document.getElementById('traditional-metrics').textContent = '';
            document.getElementById('distributed-metrics').textContent = '';
            document.getElementById('comparison-results').textContent = '';
            
            const canvas = document.getElementById('distributed-output');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // Initialize canvas
        const canvas = document.getElementById('distributed-output');
        canvas.width = 400;
        canvas.height = 300;
    </script>
</body>
</html>