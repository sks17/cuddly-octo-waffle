/**
 * Client-side background renderer from render specifications
 * 
 * This module takes a render spec generated by the backend and produces
 * pixel-perfect identical images using HTML5 Canvas, without requiring
 * the backend to generate full PNG images.
 * 
 * Key principles:
 * - Mathematical behavior is preserved (all determinant calculations done server-side)
 * - Pixel rendering is moved to client-side to reduce backend memory pressure
 * - Visual output must be identical to server-side rendering
 */

// Robust fetch helper for localhost development - handles cold starts and network issues
async function fetchWithRetry(url: string, options: RequestInit, maxRetries: number = 3): Promise<Response> {
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    console.log(`[distributed-render] fetch attempt ${attempt + 1}/${maxRetries + 1}: ${url}`);
    
    try {
      // Setup timeout with AbortController
      const controller = new AbortController();
      const timeoutMs = 30000; // 30 second timeout
      const timeout = setTimeout(() => {
        controller.abort();
        console.log(`[distributed-render] fetch timeout after ${timeoutMs}ms`);
      }, timeoutMs);
      
      const response = await fetch(url, {
        ...options,
        signal: controller.signal
      });
      
      clearTimeout(timeout);
      console.log(`[distributed-render] backend responded: ${response.status} ${response.statusText}`);
      return response;
      
    } catch (error) {
      const isNetworkError = error instanceof Error && 
        (error.name === 'AbortError' || error.name === 'TypeError' || error.message.includes('fetch'));
      
      if (attempt === maxRetries) {
        console.error(`[distributed-render] fetch failed after ${maxRetries + 1} attempts:`, error);
        throw error;
      }
      
      if (isNetworkError) {
        const delay = Math.pow(2, attempt) * 1000; // Exponential backoff: 1s, 2s, 4s
        console.log(`[distributed-render] backend warming up, retrying in ${delay}ms (${attempt + 1}/${maxRetries})`);
        await new Promise(resolve => setTimeout(resolve, delay));
      } else {
        // Don't retry non-network errors (4xx responses, etc.)
        throw error;
      }
    }
  }
  throw new Error('Max retries exceeded');
}

export interface RenderSpec {
  canvas: {
    width: number;
    height: number;
    cell_size: number;
  };
  visual: {
    hue: string;
    normalizer: number;
    low: number;
    high: number;
    blur_sigma: number;
    vignette_strength: number;
    feather_strength: number;
    use_determinant: boolean;
    use_max: boolean;
  };
  determinant_range: {
    min: number;
    max: number;
  };
  alpha_map?: {
    width: number;
    height: number;
    alpha_values: number[][];
  };
  blocks: Array<{
    x: number;
    y: number;
    width: number;
    height: number;
    matrix: number[][];
    determinant: number;
    size: number;
  }>;
}

/**
 * Color mapping that matches the backend hue system
 */
const HUE_COLORS: Record<string, [number, number, number]> = {
  'gray': [128, 128, 128],
  'red': [255, 64, 64],
  'orange': [255, 165, 0],
  'yellow': [255, 255, 64],
  'green': [64, 255, 64],
  'blue': [64, 64, 255],
  'purple': [160, 64, 255],
  'pink': [255, 64, 160],
  'teal': [64, 255, 160]
};

/**
 * Apply brightness and color transformation to match backend
 */
function applyColorTransform(
  brightness: number, 
  hue: string, 
  normalizer: number
): [number, number, number] {
  const baseColor = HUE_COLORS[hue] || HUE_COLORS['purple'];
  
  // Apply normalizer and brightness (match backend logic)
  const normalized = brightness * normalizer + (1 - normalizer);
  const clamped = Math.max(0, Math.min(1, normalized));
  
  return [
    Math.round(baseColor[0] * clamped),
    Math.round(baseColor[1] * clamped),
    Math.round(baseColor[2] * clamped)
  ];
}

/**
 * Calculate brightness from determinant (match backend logic)
 */
function determinantToBrightness(
  det: number,
  detMin: number,
  detMax: number,
  useDeterminant: boolean
): number {
  if (!useDeterminant || detMax === detMin) {
    return 0.5; // Default brightness
  }
  
  // Normalize determinant to 0-1 range
  return (det - detMin) / (detMax - detMin);
}

/**
 * Render a single matrix block to canvas context
 */
function renderBlock(
  ctx: CanvasRenderingContext2D,
  block: RenderSpec['blocks'][0],
  spec: RenderSpec
): void {
  const { visual, determinant_range, canvas } = spec;
  const matrix = block.matrix;
  const matrixSize = matrix.length;
  const cellSize = canvas.cell_size;
  
  // Calculate brightness factor from determinant
  let brightnessFactor = 1.0;
  if (visual.use_determinant && determinant_range.max > determinant_range.min) {
    const detNorm = (block.determinant - determinant_range.min) / (determinant_range.max - determinant_range.min);
    brightnessFactor = visual.use_max ? 
      0.5 + 0.5 * detNorm : 
      0.5 + 0.5 * (1.0 - detNorm);
  }
  
  // Render each matrix element as individual cells
  for (let i = 0; i < matrixSize; i++) {
    for (let j = 0; j < matrixSize; j++) {
      // Get base color for this matrix element
      const baseColor = colorFromInteger(
        matrix[i][j], 
        visual.low, 
        visual.high, 
        visual.normalizer, 
        visual.hue
      );
      
      // Apply brightness factor from determinant
      const r = Math.min(255, baseColor[0] * brightnessFactor);
      const g = Math.min(255, baseColor[1] * brightnessFactor);
      const b = Math.min(255, baseColor[2] * brightnessFactor);
      
      // Calculate cell position
      const cellX = block.x + j * cellSize;
      const cellY = block.y + i * cellSize;
      
      // Draw individual cell
      ctx.fillStyle = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
      ctx.fillRect(cellX, cellY, cellSize, cellSize);
    }
  }
}

/**
 * Color mapping function that matches backend color_from_integer logic
 */
function colorFromInteger(
  value: number, 
  low: number, 
  high: number, 
  normalizer: number, 
  hue: string
): [number, number, number] {
  const baseColor = HUE_COLORS[hue] || HUE_COLORS['gray'];
  
  // Color transformation based on matrix element value
  // 0 values get darker, 1 values get brighter (matching backend logic)
  const factor = value === low ? 0.3 : 1.2;
  
  const r = Math.min(255, Math.max(30, baseColor[0] * factor * normalizer + 40));
  const g = Math.min(255, Math.max(30, baseColor[1] * factor * normalizer + 40));
  const b = Math.min(255, Math.max(30, baseColor[2] * factor * normalizer + 40));
  
  return [r, g, b];
}

/**
 * Apply client-side blur effect using canvas filter
 */
function applyBlurEffect(canvas: HTMLCanvasElement, blurSigma: number): void {
  if (blurSigma <= 0) return;
  
  const ctx = canvas.getContext('2d');
  if (!ctx) return;
  
  // Apply blur filter (approximation of Gaussian blur)
  const blurPx = Math.max(1, Math.round(blurSigma * 2));
  ctx.filter = `blur(${blurPx}px)`;
  
  // Redraw canvas with blur effect
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  ctx.putImageData(imageData, 0, 0);
  ctx.filter = 'none'; // Reset filter
}

/**
 * Apply vignette effect to match backend implementation
 */
function applyVignetteEffect(canvas: HTMLCanvasElement, vignetteStrength: number): void {
  if (vignetteStrength <= 0) return;
  
  const ctx = canvas.getContext('2d');
  if (!ctx) return;
  
  const { width, height } = canvas;
  const centerX = width / 2;
  const centerY = height / 2;
  const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY);
  
  // Create radial gradient for vignette
  const vignette = ctx.createRadialGradient(
    centerX, centerY, 0,
    centerX, centerY, maxDistance
  );
  
  vignette.addColorStop(0, `rgba(0, 0, 0, 0)`);
  vignette.addColorStop(1, `rgba(0, 0, 0, ${vignetteStrength})`);
  
  // Apply vignette as overlay
  ctx.globalCompositeOperation = 'multiply';
  ctx.fillStyle = vignette;
  ctx.fillRect(0, 0, width, height);
  ctx.globalCompositeOperation = 'source-over'; // Reset blend mode
}

/**
 * Main render function: Convert render spec to canvas image
 */
export async function renderFromSpec(spec: RenderSpec): Promise<HTMLCanvasElement> {
  const canvas = document.createElement('canvas');
  canvas.width = spec.canvas.width;
  canvas.height = spec.canvas.height;
  
  const ctx = canvas.getContext('2d');
  if (!ctx) {
    throw new Error('Failed to get canvas 2D context');
  }
  
  // Fill background with black (matches backend behavior)
  ctx.fillStyle = 'rgb(0, 0, 0)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Render all blocks
  for (const block of spec.blocks) {
    renderBlock(ctx, block, spec);
  }
  
  // Apply post-processing effects
  applyBlurEffect(canvas, spec.visual.blur_sigma);
  applyVignetteEffect(canvas, spec.visual.vignette_strength);
  
  return canvas;
}

/**
 * Convert rendered canvas to blob for download/storage
 */
export async function canvasToBlob(canvas: HTMLCanvasElement): Promise<Blob> {
  return new Promise((resolve, reject) => {
    canvas.toBlob((blob) => {
      if (blob) {
        resolve(blob);
      } else {
        reject(new Error('Failed to convert canvas to blob'));
      }
    }, 'image/png');
  });
}

/**
 * Apply alpha mapping from ImgMap.jpg data (matches traditional generator behavior)
 * 
 * This function applies transparency effects based on the color intensity of ImgMap.jpg,
 * exactly matching the algorithm used in the traditional Python generator.
 */
function applyAlphaMapping(
  ctx: CanvasRenderingContext2D,
  canvas: HTMLCanvasElement,
  alphaMap: { width: number; height: number; alpha_values: number[][] }
): void {
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;
  
  // Apply alpha values from ImgMap.jpg color intensity calculation
  for (let y = 0; y < canvas.height; y++) {
    for (let x = 0; x < canvas.width; x++) {
      const pixelIndex = (y * canvas.width + x) * 4;
      
      // Get alpha value from map (scaled to canvas dimensions)
      const mapX = Math.min(Math.floor((x / canvas.width) * alphaMap.width), alphaMap.width - 1);
      const mapY = Math.min(Math.floor((y / canvas.height) * alphaMap.height), alphaMap.height - 1);
      const alpha = alphaMap.alpha_values[mapY]?.[mapX] ?? 1.0;
      
      // Apply alpha: strong colors in ImgMap → opaque canvas, weak colors → transparent
      data[pixelIndex + 3] = Math.floor(alpha * 255);
    }
  }
  
  ctx.putImageData(imageData, 0, 0);
}

/**
 * Utility: Generate background using distributed rendering
 * This is the main interface that replaces direct API calls for PNG generation
 */
export async function generateDistributedBackground(params: any): Promise<Blob> {
  // Add output_format parameter to request render spec
  const specParams = { ...params, output_format: 'spec' };
  
  // CRITICAL: Localhost frontend must NEVER call Fly.io to avoid CORS errors
  // Explicit API base selection - no env var fallback that could cause CORS
  let apiUrl: string;
  if (typeof window !== 'undefined' && (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1")) {
    apiUrl = "http://localhost:5000";
  } else {
    apiUrl = "https://mathematical-wallpaper-api.fly.dev";
  }
  
  // Fetch render specification from backend
  const response = await fetchWithRetry(`${apiUrl}/api/generate`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(specParams),
  });
  
  if (!response.ok) {
    throw new Error(`API request failed: ${response.status} ${response.statusText}`);
  }
  
  const renderSpec: RenderSpec = await response.json();
  
  // Render locally using canvas
  const canvas = await renderFromSpec(renderSpec);
  
  // Convert to blob
  return await canvasToBlob(canvas);
}